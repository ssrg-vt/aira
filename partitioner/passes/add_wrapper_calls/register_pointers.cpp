/*
 * register_pointers.cpp
 *
 *  Created on: Apr 23, 2013
 *      Author: rlyerly
 */

#include "rose.h"

#include "common.h"
#include "add_wrapper_calls_common.h"
#include "register_pointers.h"
#include "mm_call_builder.h"

/*
 * Class sets for checking purposes.
 */
set<string> RegisterPointers::headerFiles;
set<string> RegisterPointers::compilerVars;
set<string> RegisterPointers::functions;

/*
 * Constructor for registering an expression.
 */
RegisterPointers::RegisterPointers(SgExpression* p_expression) :
	expression(p_expression),
	varName(NULL),
	varSymbol(NULL),
	isGlobal(false),
	definedInSystemHeader(false),
	compilerGenerated(false),
	addrUsedInIO(false)
{
	//TODO maybe need to do a while loop until we get a var ref?
	ROSE_ASSERT(isSgPointerType(expression->get_type()));
	SgAddressOfOp* addrOf = isSgAddressOfOp(expression);
	if(addrOf)
	{
		//Check to make sure we don't register vars the compiler added
		SgVarRefExp* varRef = isSgVarRefExp(addrOf->get_operand());
		if(varRef)
		{
			varSymbol = varRef->get_symbol();
			compilerGenerated = isCompilerGenerated(varSymbol);
			addrUsedInIO = isAddrTakenInIrrelevantFunc(varRef);
		}
	}
}

/*
 * Constructor for registering an array
 */
RegisterPointers::RegisterPointers(SgInitializedName* p_varName, bool p_isGlobal) :
	expression(NULL),
	varName(p_varName),
	varSymbol(NULL),
	isGlobal(p_isGlobal),
	definedInSystemHeader(false),
	compilerGenerated(false),
	addrUsedInIO(false)
{
	definedInSystemHeader = isDefinedInSystemHeaders(varName);
	varSymbol = isSgVariableSymbol(varName->search_for_symbol_from_symbol_table());
	ROSE_ASSERT(varSymbol != NULL);
	compilerGenerated = isCompilerGenerated(varSymbol);
}

/*
 * Check to see if a variable is declared in a system header.
 */
bool RegisterPointers::isDefinedInSystemHeaders(SgInitializedName* var)
{
	string filename = varName->get_file_info()->get_filenameString();

	set<string>::const_iterator fileIt = headerFiles.begin();
	for(fileIt = headerFiles.begin(); fileIt != headerFiles.end(); fileIt++)
	{
		if(filename.find(*fileIt) != string::npos)
			return true;
	}
	return false;
}

/*
 * Check to see if a variable was generated by the compiler.
 */
bool RegisterPointers::isCompilerGenerated(SgSymbol* var)
{
	string name = NAME(var);

	set<string>::const_iterator varIt = compilerVars.begin();
	for(varIt = compilerVars.begin(); varIt != compilerVars.end(); varIt++)
	{
		if(name.find(*varIt) != string::npos)
			return true;
	}
	return false;
}

/*
 * Check to see if a variable has its address taken in an I/O operation.
 */
bool RegisterPointers::isAddrTakenInIrrelevantFunc(SgVarRefExp* expr)
{
	//TODO get function call name
	/*SgExprStatement* stmt = isSgExprStatement(getEnclosingStatement(expr));
	if(!stmt)
		return false;
	SgFunctionCallExp* funcCall = isSgFunctionCallExp(stmt->get_expression());
	if(!funcCall)
		return false;
	string name = NAME(funcCall->getAssociatedFunctionSymbol());*/

	SgStatement* encStmt = getEnclosingStatement(expr);
	SgNode* parent = expr->get_parent();
	SgFunctionCallExp* funcCall = NULL;
	while(parent != encStmt)
	{
		funcCall = isSgFunctionCallExp(parent);
		if(funcCall &&
				(functions.find(NAME(funcCall->getAssociatedFunctionSymbol())) != functions.end()))
			return true;

		parent = parent->get_parent();
	}

	/*set<string>::const_iterator funcIt = functions.begin();
	for(funcIt = functions.begin(); funcIt != functions.end(); funcIt++)
	{
		if(name.find(*funcIt) != string::npos)
			return true;
	}*/
	return false;
}

/*
 * Add calls to register and unregister expressions/arrays with the memory
 * management wrapper.
 */
bool RegisterPointers::addRegUnregCalls()
{
	string msg;

	if(definedInSystemHeader)
	{
		msg = "\t\t\tVariable " + NAME(varSymbol) + " is in system headers";
		WARNING(TOOL, msg);
		return false;
	}

	if(compilerGenerated)
	{
		msg = "\t\t\tVariable " + NAME(varSymbol) + " is compiler-generated";
		WARNING(TOOL, msg);
		return false;
	}

	if(addrUsedInIO)
	{
		msg = "\t\t\tVariable " + NAME(varSymbol) + " has its address taken in "
				+ "a function known to not require registering/unregistering";
		WARNING(TOOL, msg);
		return false;
	}

	//Add register/unregister calls
	SgStatement* prevStmt = NULL;
	SgExprStatement* funcCall = NULL;
	SgType* type = NULL;
	SgExpression* expr = NULL;

	if(isGlobal)
	{
		type = varName->get_type();
		SgName name = varName->get_name();
		int numVals = 1;

		if(isSgPointerType(type))
			return false;	//If its a pointer, it points to a static array, dynamic array, or scalar
							//which has its address taken (all of which have already been registered)

		SgFunctionDeclaration* main = findMain(getScope(varName));
		ROSE_ASSERT(main);
		expr = buildVarRefExp(name, varName->get_scope());
		if(isSgArrayType(type))
			numVals = getArrayElementCount(isSgArrayType(type));
		else
			expr = buildAddressOfOp(expr);

		funcCall = MMCallBuilder::buildRegisterPointerCall(expr, buildUnsignedIntVal(numVals),
				main->get_definition());
		insertStatement(getFirstStatement(main->get_definition()), funcCall);//, false, true);
		funcCall = MMCallBuilder::buildUnregisterPointerCall(expr, main->get_definition());
		instrumentEndOfFunction(main, funcCall);
	}
	else if(expression) //Address-of expressions
	{
		prevStmt = getEnclosingStatement(expression);
		funcCall = MMCallBuilder::buildRegisterPointerCall(expression, buildUnsignedIntVal(1),
				getScope(expression));
		insertStatement(prevStmt, funcCall);
		funcCall = MMCallBuilder::buildUnregisterPointerCall(expression, getScope(expression));
		instrumentEndOfFunction(getEnclosingFunctionDeclaration(prevStmt), funcCall);
	}
	else //Array types
	{
		SgVarRefExp* varRef = buildVarRefExp(varName, getScope(varName));

		int numVals = getArrayElementCount(isSgArrayType(varName->get_type()));
		funcCall = MMCallBuilder::buildRegisterPointerCall(varRef, buildUnsignedIntVal(numVals),
				varName->get_scope());
		insertStatement(varName->get_declaration(), funcCall, false, true);
		varRef = buildVarRefExp(varName, getScope(varName));
		funcCall = MMCallBuilder::buildUnregisterPointerCall(varRef, varName->get_scope());
		instrumentEndOfFunction(getEnclosingFunctionDeclaration(varName), funcCall);
	}

	return true;
}

/*
 * Initialize necessary class data structures.
 */
void RegisterPointers::initialize()
{
	initializeSystemHeaderSet();
	initializeCompilerVarsSet();
	initializeFuncSet();
}

/*
 * Initialize a set of system header files so variables can be checked to see
 * if they are opaque.
 */
void RegisterPointers::initializeSystemHeaderSet()
{
	//All standard Linux headers
	headerFiles.insert("/usr/include");

	//OpenMP headers
	headerFiles.insert("/omp.h");

	//MPI headers
	headerFiles.insert("/mpi.h");
}

/*
 * Initialize a set of compiler-generated variables to avoid when
 * registering/unregistering variables.
 */
void RegisterPointers::initializeCompilerVarsSet()
{
	//Variable to tell MPI partition to exit
	compilerVars.insert("__finished__");
	compilerVars.insert("__num_proc__");

	//MPI status variables
	compilerVars.insert("__mpi_status__");

	//Variable to tell MPI partition which function to execute
	compilerVars.insert("__func_num__");

	//Any compiler-generated size variables
	compilerVars.insert("__size");

	//MPI datatype declaration variables
	compilerVars.insert("__types");
	compilerVars.insert("__sizes");
	compilerVars.insert("__extents");
}

/*
 * Initialize the set of I/O operations where a variable has its address
 * taken, but we do not necessarily want to save the address.
 */
void RegisterPointers::initializeFuncSet()
{
	//MPI Functions
	functions.insert("MPI_Init");
	functions.insert("MPI_Send");
	functions.insert("MPI_Receive");

	//File I/O
	functions.insert("fscanf");
	functions.insert("sscanf");
}
